<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Data Visualisation: Unofficial World Football Champions</title>
    <meta charset="utf-8"><meta property="og:url" content="http://www.andybarefoot.com/football/world-champions.html">
    <meta property="og:title" content="Unofficial Football World Championships">
    <meta property="og:description" content="Animated map of the different countries to win or challenge for the Unofficial World Football Championship.">
    <meta property="og:image" content="http://www.andybarefoot.com/football/images/fb-football-world-champs.png">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <script type="text/javascript" src="/jscript/d3.v3.js"></script>
    <script type="text/javascript" src="data/countries.js"></script>
    <script type="text/javascript" src="data/games.js"></script>
    <script src="/jscript/analyticstracking.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Abril+Fatface|Yanone+Kaffeesatz:200" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300" rel="stylesheet">
    <link rel="stylesheet" href="css/ufwc-map.css">
  </head>

  <body>
    <div id="navigation">
      <div id="controls">
        <a id="info" href="javascript:openOverlay()">i</a>
        <a href="javascript:playVis()"><img id="play" src="images/icons/play-on.png" alt="Play animation"></a>
        <a href="javascript:stopVis()"><img id="pause" src="images/icons/pause-off.png" alt="Pause animation"></a>
        <a href="javascript:goToFirst()"><img id="start" src="images/icons/start-on.png" alt="Jump to first game"></a>
        <a href="javascript:slower()"><img id="slower" src="images/icons/rewind-off.png" alt="Decrease animation speed"></a>
        <a href="javascript:faster()"><img id="faster" src="images/icons/forward-off.png" alt="Increase animation speed"></a>
        <a href="javascript:goToLast()"><img id="end" src="images/icons/end-on.png" alt="Jump to last game" ></a>
      </div>
      <div id="currentGameDetails">
        <span id="detailsNo">&nbsp;</span><br/>
        <span id="detailsResult">&nbsp;</span><br/>
        <span id="detailsEvent">&nbsp;</span>
        <span id="detailsVenue">&nbsp;</span>
      </div>
      <div id="champions">
        <h2>Unofficial World Football Champions:</h2>
        <span id="detailsChampions">&nbsp;</span>
      </div>
      <div id="progressBar">
      </div>
    </div>

    <div id="overlay">
      <div id="textContent">
        <h1><span id="t1">UNOFFICIAL</span> <span id="t2">WORLD</span> <span id="t3">FOOTBALL</span> <span id="t4">CHAMPIONS</span></h1>
        <p>The Unofficial Football World Championships imagines what would happen if the World Football Champions were not decided once every four years at a tournament but instead followed the boxing model.</p>
        <p>Starting from the very first international game between Scotland and England the reigning World Champions retain their crown only until the next match they lose, at which point the title transfers to their victorious opponents.</p>
        <p>This magnificent folly is documented at the <a href="http://www.ufwc.co.uk/" target="ufsc">Unofficial Football World Championships</a> and this is merely an exercise in data visualisation based on their results.</p>
        <p>The interactive map shows all the countries that have taken part in the UFWC matches so far. Use the controls in the top left corner to play an animation showing how the UWFC has been contested between teams as unlikely as the Netherland Antilles, Libya, North Korea and Guam.</p>
        <p>Key:</p>
        <p><img src="images/icons/key-champ.png"> Current Champion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="images/icons/key-chall.png"> Last challenger&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="images/icons/key-ex-champ.png"> Ex-champion &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="images/icons/key-ex-chall.png"> Ex-challenger<br/>
        <img src="images/icons/key-score.png"> Times won or defended championship</p>
        <p id="close"><a href="javascript:closeOverlay()">[X]</a></p>
     </div>
   </div>

    <div id="progressFlag"></div>

    <script type="text/javascript">
      // scalefactor
      // - to view whole map left to right scale = width/2*PI

      //Globals for use later
      //Width and height
      var w = 8000;
      var h = 3200;
      // colours
      var oceanColour = "#2A2C39";
      var landColour = "#5c6672";
      var championColour = "#f9b031";
      var challengerColour = "#d0d0d0";
      var pastChampionColour = "#ab8d5b"
      var pastChallengerColour = "#79818a";
      // animation settings
      var currentGame;
      var frameGap = 1500;
      var zoomDuration = 500;
      var minGap = 300;
      var maxGap = 3000;
      var playing = false;
      // map initial settings
      var initScale = [w/(2*Math.PI)];
      var initTranslate = [w/2, h/2];

      var countriesGroup;

      var homeCode;
      var awayCode;

      var gameDisplayOffsetX = 300;
      var gameDisplayOffsetY = 200;

      var gameDisplayX = gameDisplayOffsetX;
      var gameDisplayY = gameDisplayOffsetY;

      //Define map projection
      var projection = d3.geo.equirectangular()
        .center([0, 14])
        .translate(initTranslate)
        .scale(initScale)
      ;

      var zoom = d3.behavior.zoom()
        .on("zoom", zoomed)
      ;

      //Define path generator
      var path = d3.geo.path()
        .projection(projection)
      ;

      //Create SVG element
      var svg = d3.select("body")
        .append("svg")
        .attr("viewBox", "0 0 " + $( window ).width() + " " + ($(window).height() - $("#navigation").height()))
        .call(zoom)
      ;

      $(window).resize(function() {
        $(".progressButton").width($(window).width()/gamesData.length);
        svg
          .attr("viewBox", "0 0 " + $(window).width() + " " + ($(window).height() - $("#navigation").height()))
        ;
        moveProgressFlag();
        sizeDisplayBox();
        displayGame(currentGame);
      });

      function sizeDisplayBox(){
        if($("svg").width()>=1200){
          gameDisplayOffsetX = 300;
          gameDisplayOffsetY = 200;
          gameDisplayRect
            .attr("x", -190)
            .attr("y", -100)
            .attr("width", 380)
            .attr("height", 200)
          ;
          gameNoTxt.attr("dy", -60);
          gameHomeTxt.attr("dy", -25);
          gameScoreTxt.attr("dy", 5);
          gameAwayTxt.attr("dy", 35);
          gameDetailsTxt.attr("dy", 68);
        }else{
          gameDisplayOffsetX = 180;
          gameDisplayOffsetY = 100;
          gameDisplayRect
            .attr("x", -150)
            .attr("y", -70)
            .attr("width", 300)
            .attr("height", 140)
          ;
          gameNoTxt.attr("dy", -40);
          gameHomeTxt.attr("dy", -15);
          gameScoreTxt.attr("dy", 5);
          gameAwayTxt.attr("dy", 25);
          gameDetailsTxt.attr("dy", 48);
        }
      }

      function initZoom(){
        bestFit = Math.max($( window ).width()/w,$( window ).height()/h);
        zoom.scaleExtent([bestFit, 40*bestFit])
        initScale = Math.max($( window ).width()/w,$( window ).height()/h);
      }

// zoom to show an area defined by coordinates as large as possible within available screen size
      function zoomed() {
        dx = d3.event.translate[0];
        dy = d3.event.translate[1];
        dx = Math.min(0,dx);
        dy = Math.min(0,dy);
        dx = Math.max($("svg").width() - w*d3.event.scale,dx);
        dy = Math.max($("svg").height() - h*d3.event.scale,dy);
        zoom.translate([dx,dy]); 
        countriesGroup.attr("transform", "translate(" + [dx,dy] + ")scale(" + d3.event.scale + ")");
        zoomFinished();
      }

      function showLabel(labelID) {
        $("#"+labelID).show();
      }

      function hideLabel(labelID) {
        $("#"+labelID).hide();
      }

      function openOverlay(){
        $("#overlay").show();
      }

      function closeOverlay(){
        $("#overlay").hide();
      }

      //Load in GeoJSON data
      d3.json("mapdata/custom50ukSplit.json", function(json) {
//      d3.json("mapdata/justUnitedKingdom.json", function(json) {
        console.log(json);
        //Bind data and create one path per GeoJSON feature
        countriesGroup = svg
          .append("g")
          .attr("id", "map")
        ;
        countriesGroup.append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", w)
          .attr("height", h)
          .attr("fill", oceanColour)
        ;

        countries = countriesGroup
          .selectAll("path")
          .data(json.features)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("fill", landColour)
          .attr("stroke", oceanColour)
          .on("mouseover", function(d,i) {
            showLabel("countryLabel" + d.properties.iso_a3);
          })
          .on("mouseout", function(d,i) {
            hideLabel("countryLabel" + d.properties.iso_a3);
          })
          .filter(function(d) {
            return d.properties.iso_a3 === "GBR";
          })
          .remove()
        ;

        homeArrow = countriesGroup
          .append("line")
          .attr("id", "homeArrow")
          .attr("x1", 800)
          .attr("y1", 300)
          .attr("x2", 7800)
          .attr("y2", 3000)
          .attr("stroke", championColour)
          .attr("stroke-width", 10)
        ;

        awayArrow = countriesGroup
          .append("line")
          .attr("id", "awayArrow")
          .attr("x1", 900)
          .attr("x2", 1100)
          .attr("y1", 200)
          .attr("y2", 900)
          .attr("stroke", challengerColour)
          .attr("stroke-width", 10)
        ;

        countryLabels = countriesGroup
          .selectAll("g")
          .data(json.features)
          .enter()
          .append("g")
          .attr("class", "countryLabel")
          .attr("id", function(d) {
            return "countryLabel" + d.properties.iso_a3;
          })
          .attr("transform", function(d) {
            return "translate("+getCountryCentroid(d)[0]+","+getCountryCentroid(d)[1]+")";
          })
          .on("mouseover", function(d,i) {
            showLabel("countryLabel" + d.properties.iso_a3);
          })
          .on("mouseout", function(d,i) {
            hideLabel("countryLabel" + d.properties.iso_a3);
          })
        ;

        countryLabels
          .append("text")
          .attr("class", "countryName")
          .attr("fill", challengerColour)
          .style("text-anchor", "middle")
          .attr("dx", 0)
          .attr("dy", 0)
          .text(function(d) {
            return d.properties.name;
          })
          .call(getTextBox)
        ;

        countryLabels
          .insert("rect","text")
          .attr("transform", function(d) {
            return "translate("+(d.bbox.x-2)+","+(d.bbox.y)+")";
          })
          .attr("width", function(d){return (d.bbox.width+4)})
          .attr("height", function(d){return d.bbox.height})
          .style("fill", oceanColour)
        ;

        scoreLabels = countriesGroup
          .selectAll(".scorelabel")
          .data(json.features)
          .enter()
          .append("g")
          .attr("class", "scoreLabel")
          .attr("id", function(d) {
            return "scoreLabel" + d.properties.iso_a3;
          })
          .attr("transform", function(d) {
            return "translate("+getCountryCentroid(d)[0]+","+(getCountryCentroid(d)[1]+20)+")";
          })
          .on("mouseover", function(d,i) {
            showLabel("countryLabel" + d.properties.iso_a3);
          })
          .on("mouseout", function(d,i) {
            hideLabel("countryLabel" + d.properties.iso_a3);
          })
        ;

        scoreLabels
          .append("circle")
          .attr("cx", 0)
          .attr("cy", 0)
          .attr("r", 12)
          .style("fill", oceanColour)
        ;

        scoreLabels
          .append("text")
          .attr("class", "labelScore")
          .attr("id", function(d) {
            return "labelScore" + d.properties.iso_a3;
          })
          .attr("fill", challengerColour)
          .style("text-anchor", "middle")
          .attr("dx", 0)
          .attr("dy", 5)
          .text(28)
        ;


        gameDisplay = svg
          .append("g")
          .attr("id", "gameDisplay")
          .attr("transform", "translate("+gameDisplayX+","+gameDisplayY+")")
        ;

        gameDisplayRect = gameDisplay
          .append("rect")
          .attr("x", -190)
          .attr("y", -100)
          .attr("width", 380)
          .attr("height", 200)
          .attr("fill", oceanColour)
          .attr("stroke", championColour)
          .attr("stroke-width", 2)
        ;

        gameNoTxt = gameDisplay
          .append("text")
          .attr("id", "gameNo")
          .attr("fill", challengerColour)
          .style("text-anchor", "middle")
          .attr("dx", 0)
          .attr("dy", -60)
          .text("Match No. 123/926")
        ;

        gameHomeTxt = gameDisplay
          .append("text")
          .attr("id", "gameHome")
          .attr("fill", challengerColour)
          .style("text-anchor", "middle")
          .attr("dx", 0)
          .attr("dy", -25)
          .text("TRINIDAD & TOBAGO")
        ;

        gameScoreTxt = gameDisplay
          .append("text")
          .attr("id", "gameScore")
          .attr("fill", challengerColour)
          .style("text-anchor", "middle")
          .attr("dx", 0)
          .attr("dy", 5)
          .text("1-0")
        ;

        gameAwayTxt = gameDisplay
          .append("text")
          .attr("id", "gameAway")
          .attr("fill", challengerColour)
          .style("text-anchor", "middle")
          .attr("dx", 0)
          .attr("dy", 35)
          .text("CZECHOSLOVAKIA")
        ;

        gameDetailsTxt = gameDisplay
          .append("text")
          .attr("id", "gameDetails")
          .attr("fill", challengerColour)
          .style("text-anchor", "middle")
          .attr("dx", 0)
          .attr("dy", 68)
          .text("China Cup Qualifier - NANNING (15/01/2017)")
        ;
        sizeDisplayBox();
        initZoom();
        goToLast();
      });

      function getTextBox(selection) {
        selection.each(function(d) { d.bbox = this.getBBox(); })
      }

      function findTeamIndex(teamVal){
        for(var i = 0; i<teamsData.length; i++) {
            if(teamsData[i][0] == teamVal) return i;
        }
        return -1;
      }

      function findTeamCode(teamVal){
        for(var i = 0; i<teamsData.length; i++) {
            if(teamsData[i][0] == teamVal) return teamsData[i][2];
        }
        return "";
      }


      function countryStroke(countryID, strokeColour, strokeThickness){
        countriesGroup.selectAll('path')
          .filter(function(d) {
            return d.properties.iso_a3 === countryID
          })
          .style('stroke', strokeColour)
          .style('stroke-width', strokeThickness)
      }

      function countryFill(countryID, fillColour){
        countriesGroup.selectAll('path')
          .filter(function(d) {
            return d.properties.iso_a3 === countryID
          })
          .style('fill', fillColour)
      }

      function boxZoom(box, paddingPerc){
        point1 = box[0];
        point2 = box[1];
        // find size of map area defined
        zoomWidth = Math.abs(point1[0]-point2[0]);
        zoomHeight = Math.abs(point1[1]-point2[1]);
        // increase map area to include padding
        zoomWidth = zoomWidth * (100+paddingPerc)/100;
        zoomHeight = zoomHeight * (100+paddingPerc)/100;
        // find midpoint of map area defined
        zoomMidX = (point1[0]+point2[0])/2;
        zoomMidY = (point1[1]+point2[1])/2;
        // find scale required for area to fill svg
        maxXscale = $("svg").width()/zoomWidth;
        maxYscale = $("svg").height()/zoomHeight;
        zoomScale = Math.min(maxXscale, maxYscale);
        // Find screen pixel equivalent once scaled
        offsetX = zoomScale*zoomMidX;
        offsetY = zoomScale*zoomMidY;
        // Find offset to centre, making sure no gap at left or top of holder
        dleft = Math.min(0,($("svg").width()/2)-offsetX);
        dtop = Math.min(0,($("svg").height()/2)-offsetY);
        // Make sure no gap at bottom or right of holder
        dleft = Math.max($("svg").width()-(w*zoomScale),dleft);
        dtop = Math.max($("svg").height()-(h*zoomScale),dtop);
        zoom.translate([dleft,dtop]).scale(zoomScale); 
//        zoom.translate([0,0]).scale(zoomScale); 
        countriesGroup
          .transition()
          .duration(zoomDuration)
          .attr("transform", "translate(" + [dleft,dtop] + ")scale(" + zoomScale + ")")
          .each("end", zoomFinished);
        ;

      }

      function zoomFinished(){
        newScale = countriesGroup.node().getCTM().a;
        newXoffset = countriesGroup.node().getCTM().e;
        newYoffset = countriesGroup.node().getCTM().f;
        currentWinner = gamesData[currentGame-1][0];
        currentHome = gamesData[currentGame-1][1];
        currentAway = gamesData[currentGame-1][3];
        currentIndexH = findTeamIndex(currentHome);
        currentIndexA = findTeamIndex(currentAway);
        winnerIndex = findTeamIndex(currentWinner);
        homeCode = findTeamCode(currentHome);
        awayCode = findTeamCode(currentAway);
        winnerCode = findTeamCode(currentWinner);
        // update score labels
        d3.select("#labelScore"+winnerCode).text(teamsData[winnerIndex][4]);
        $("#scoreLabel"+winnerCode).show();
        homeFeature = countriesGroup.selectAll('path')
          .filter(function(d) {
            return d.properties.iso_a3 === homeCode;
          })
        ;
        awayFeature = countriesGroup.selectAll('path')
          .filter(function(d) {
            return d.properties.iso_a3 === awayCode;
          })
        ;
        homeFeature = countriesGroup.selectAll('path')
          .filter(function(d) {
            return d.properties.iso_a3 === homeCode;
          })
        ;
        awayFeature = countriesGroup.selectAll('path')
          .filter(function(d) {
            return d.properties.iso_a3 === awayCode;
          })
        ;
        homeArrow
          .attr("x2", getCountryCentroid(homeFeature.datum())[0])
          .attr("y2", getCountryCentroid(homeFeature.datum())[1])
        ;
        awayArrow
          .attr("x2", getCountryCentroid(awayFeature.datum())[0])
          .attr("y2", getCountryCentroid(awayFeature.datum())[1])
        ;

        homeCentroidX = getCountryCentroid(homeFeature.datum())[0];
        homeCentroidY = getCountryCentroid(homeFeature.datum())[1];
        awayCentroidX = getCountryCentroid(awayFeature.datum())[0];
        awayCentroidY = getCountryCentroid(awayFeature.datum())[1];
        homeScreenX = (homeCentroidX*newScale)+newXoffset;
        homeScreenY = (homeCentroidY*newScale)+newYoffset;
        awayScreenX = (awayCentroidX*newScale)+newXoffset;
        awayScreenY = (awayCentroidY*newScale)+newYoffset;
        // display correct country colours
        if(winnerIndex==currentIndexH){
          countryFill(homeCode,championColour);
          homeArrow.attr("stroke",championColour);
        }else{
          countryFill(homeCode,challengerColour);
          homeArrow.attr("stroke",challengerColour);
        }
        if(winnerIndex==currentIndexA){
          countryFill(awayCode,championColour);
          awayArrow.attr("stroke",championColour);
        }else{
          countryFill(awayCode,challengerColour);
          awayArrow.attr("stroke",challengerColour);
        }
 
        quads=[0,0,0,0];
        if(homeScreenX<$("svg").width()/2){
          // home is at left
          if(homeScreenY<$("svg").height()/2){
            // home is at top left
            quads[0]++;
          }else{
            // home is at bottom left
            quads[2]++;
          }
        }else{
          // home is at right
          if(homeScreenY<$("svg").height()/2){
            // home is at top right
            quads[1]++;
          }else{
            // home is at bottom right
            quads[3]++;
          }
        }
        if(awayScreenX<$("svg").width()/2){
          // away is at left
          if(awayScreenY<$("svg").height()/2){
            // away is at top left
            quads[0]++;
          }else{
            // away is at bottom left
            quads[2]++;
          }
        }else{
          // away is at right
          if(awayScreenY<$("svg").height()/2){
            // away is at top right
            quads[1]++;
          }else{
            // away is at bottom right
            quads[3]++;
          }
        }
        if(quads[0]==2){
          gameDisplayX = $("svg").width()-gameDisplayOffsetX;
          gameDisplayY = $("svg").height()-gameDisplayOffsetY;
        }else if(quads[1]==2){
           gameDisplayX = gameDisplayOffsetX;
           gameDisplayY = $("svg").height()-gameDisplayOffsetY;
        }else if(quads[2]==2){
           gameDisplayX = $("svg").width()-gameDisplayOffsetX;
           gameDisplayY = gameDisplayOffsetY;
        }else if(quads[3]==2){
           gameDisplayX = gameDisplayOffsetX;
           gameDisplayY = gameDisplayOffsetY;
        }else if(quads[0]==0){
           gameDisplayX = gameDisplayOffsetX;
           gameDisplayY = gameDisplayOffsetY;
        }else if(quads[1]==0){
           gameDisplayX = $("svg").width()-gameDisplayOffsetX;
           gameDisplayY = gameDisplayOffsetY;
        }else if(quads[2]==0){
           gameDisplayX = gameDisplayOffsetX;
           gameDisplayY = $("svg").height()-gameDisplayOffsetY;
        }else {
           gameDisplayX = $("svg").width()-gameDisplayOffsetX;
           gameDisplayY = $("svg").height()-gameDisplayOffsetY;
        }
        gameDisplay
          .attr("transform", "translate("+gameDisplayX+","+gameDisplayY+")")
        ;
        homeArrow
          .attr("x1", (gameDisplayX-newXoffset)/newScale)
          .attr("y1", (gameDisplayY-newYoffset)/newScale)
          .attr("stroke-width", 2/newScale)
        ;
        awayArrow
          .attr("x1", (gameDisplayX-newXoffset)/newScale)
          .attr("y1", (gameDisplayY-newYoffset)/newScale)
          .attr("stroke-width", 2/newScale)
        ;

        $("#gameDisplay").show();
        $("#homeArrow").show();
        $("#awayArrow").show();
     }

      function getCountryBounds(countryID){
        countryFeature = countriesGroup.selectAll('path')
          .filter(function(d) {
            return d.properties.iso_a3 === countryID
          })
          .datum();
        pureBounds = path.bounds(countryFeature);
        // hack the bounds for nicer display for certain countries
        // ignore some French colonies
        if(countryID=="FRA"){
          pureBounds = [[3890,775.6195746527787],[4240,1000]];
        }
        // ignore Norways arctic area
        if(countryID=="NOR"){
          pureBounds = [[4152,280],[4700,622]];
        }
        // ignore some Dutch colonies
        if(countryID=="NLD"){
          pureBounds = [[4075,715],[4160,780]];
        }
        // ignore some Portuguese colonies
        if(countryID=="PRT"){
          pureBounds = [[3790,974.7243923611107],[3861.9444444444443,1090]];
        }
        // US mainland only
        if(countryID=="USA"){
          pureBounds = [[1230,810],[2520.9444444444443,1370]];
        }
        // Chile mainland only
        if(countryID=="CHL"){
          pureBounds = [[2320,2300.1345486111104],[2523.649088541667,3153.148871527778]];
        }
        // Smaller area of Russia
        if(countryID=="RUS"){
          pureBounds = [[4610,350],[6200,1000]];
        }
        // igonre BAlearics for Spain
        if(countryID=="ESP"){
          pureBounds = [[3790,938.5655381944433],[4096.046006944445,1120]];
        }
        return pureBounds;
      }

      // FIX CENTROIDS
      function getCountryCentroid(feature){
        pureCentroid = path.centroid(feature);
        if(feature.properties.iso_a3=="FRA"){
          pureCentroid = [4050,880];
        }
        if(feature.properties.iso_a3=="NOR"){
          pureCentroid = [4200,550];
        }
        if(feature.properties.iso_a3=="USA"){
          pureCentroid = [1800,1050];
        }
        if(feature.properties.iso_a3=="CHL"){
          pureCentroid = [2390,2750];
        }
        if(feature.properties.iso_a3=="RUS"){
          pureCentroid = [5800,600];
        }
        return pureCentroid;
      }
      /*
      FRA
      */

      function combineBounds(bounds){
        maxX = 0;
        minX = w;
        maxY = 0;
        minY = h;
        for(i=0;i<bounds.length;i++){
          if(bounds[i][0][0]<minX)minX = bounds[i][0][0];
          if(bounds[i][0][1]<minY)minY = bounds[i][0][1];
          if(bounds[i][1][0]>maxX)maxX = bounds[i][1][0];
          if(bounds[i][1][1]>maxY)maxY = bounds[i][1][1];
        }
        return [[minX,minY],[maxX,maxY]];
      }

      function moveProgressFlag(game){
        game = game || currentGame;
        var position = $("#progButton"+game).offset();
        position.top+=12;
        if(position.left<11){
          $("#progressFlag").css("background-image", "url('images/icons/prog-flag-l.png')"); 
        }else if(position.left>($(window).width()-23)){
          $("#progressFlag").css("background-image", "url('images/icons/prog-flag-r.png')");
          position.left-=23;
        }else{
          $("#progressFlag").css("background-image", "url('images/icons/prog-flag.png')");
          position.left-=11;
        }
        $("#progressFlag").css(position);
        $("#progressFlag").html(game);
      }


      // display the passed game as the current game
      function displayGame(gameNo){
        $("#gameDisplay").hide();
        $("#homeArrow").hide();
        $("#awayArrow").hide();
        // get details of game (teams, champion, etc)
        currentWinner = gamesData[gameNo-1][0];
        currentHome = gamesData[gameNo-1][1];
        currentAway = gamesData[gameNo-1][3];
        currentScore = gamesData[gameNo-1][2];
        currentTournament = gamesData[gameNo-1][4];
        currentDate = gamesData[gameNo-1][5];
        currentVenue = gamesData[gameNo-1][6];
        currentIndexH = findTeamIndex(currentHome);
        currentIndexA = findTeamIndex(currentAway);
        winnerIndex = findTeamIndex(currentWinner);
        homeCode = findTeamCode(currentHome);
        awayCode = findTeamCode(currentAway);
        winnerCode = findTeamCode(currentWinner);
        // update progress bar
        $(".progressButton").css("background-color",challengerColour);
        $("#progButton"+gameNo).css("background-color",championColour);
        moveProgressFlag();
        // display game details in game display box
        gameNoTxt.text("Match No. " + gameNo + "/" + gamesData.length);
        gameHomeTxt.text(currentHome);
        gameScoreTxt.text(currentScore);
        gameAwayTxt.text(currentAway);
        gameDetailsTxt.text(currentTournament + " - " + currentVenue + " (" + currentDate + ")");
        if(winnerCode==homeCode){
          gameHomeTxt.attr("fill",championColour);
        }else{
          gameHomeTxt.attr("fill",challengerColour);
        }
        if(winnerCode==awayCode){
          gameAwayTxt.attr("fill",championColour);
        }else{
          gameAwayTxt.attr("fill",challengerColour);
        }
        // display game details in navigation
        $("#detailsNo").text("Match No. " + gameNo + "/" + gamesData.length);
        $("#detailsResult").text(currentHome + " " + currentScore + " " + currentAway);
        $("#detailsEvent").text(currentTournament);
        $("#detailsVenue").text(" - " + currentVenue + " (" + currentDate + ")");
        if(currentWinner==""){
          $("#detailsChampions").text("NO CHAMPION");
        }else{
          $("#detailsChampions").text(currentWinner);
        }
        // zoom to countries on map
        boundArray = [];
        boundArray.push(getCountryBounds(homeCode));
        boundArray.push(getCountryBounds(awayCode));
        combinedBound = combineBounds(boundArray);
        boxZoom(combinedBound, 20);
  }

      // display the passed game as the current game
      function displayGameOld(gameNo){
        $("#gameDisplay").hide();
        $("#homeArrow").hide();
        $("#awayArrow").hide();
        // get details of game (teams, champion, etc)
        currentWinner = gamesData[gameNo-1][0];
        currentHome = gamesData[gameNo-1][1];
        currentAway = gamesData[gameNo-1][3];
        currentScore = gamesData[gameNo-1][2];
        currentTournament = gamesData[gameNo-1][4];
        currentDate = gamesData[gameNo-1][5];
        currentVenue = gamesData[gameNo-1][6];
        currentIndexH = findTeamIndex(currentHome);
        currentIndexA = findTeamIndex(currentAway);
        winnerIndex = findTeamIndex(currentWinner);
        homeCode = findTeamCode(currentHome);
        awayCode = findTeamCode(currentAway);
        winnerCode = findTeamCode(currentWinner);
        // update progress bar
        $(".progressButton").css("background-color",challengerColour);
        $("#progButton"+gameNo).css("background-color",championColour);
        // display game details in game display box
        gameNoTxt.text("Match No. " + gameNo + "/" + gamesData.length);
        gameHomeTxt.text(currentHome);
        gameScoreTxt.text(currentScore);
        gameAwayTxt.text(currentAway);
        gameDetailsTxt.text(currentTournament + " - " + currentVenue + " (" + currentDate + ")");
        if(winnerCode==homeCode){
          gameHomeTxt.attr("fill",championColour);
        }else{
          gameHomeTxt.attr("fill",challengerColour);
        }
        if(winnerCode==awayCode){
          gameAwayTxt.attr("fill",championColour);
        }else{
          gameAwayTxt.attr("fill",challengerColour);
        }
        // display game details in navigation
        $("#detailsNo").text("Match No. " + gameNo + "/" + gamesData.length);
        $("#detailsResult").text(currentHome + " " + currentScore + " " + currentAway);
        $("#detailsEvent").text(currentTournament);
        $("#detailsVenue").text(" - " + currentVenue + " (" + currentDate + ")");
        if(currentWinner==""){
          $("#detailsChampions").text("NO CHAMPION");
        }else{
          $("#detailsChampions").text(currentWinner);
        }
        // display correct country colours
        if(winnerIndex==currentIndexH){
          countryFill(homeCode,championColour);
          homeArrow.attr("stroke",championColour);
        }else{
          countryFill(homeCode,challengerColour);
          homeArrow.attr("stroke",challengerColour);
        }
        if(winnerIndex==currentIndexA){
          countryFill(awayCode,championColour);
          awayArrow.attr("stroke",championColour);
        }else{
          countryFill(awayCode,challengerColour);
          awayArrow.attr("stroke",challengerColour);
        }
        // zoom to countries on map
        boundArray = [];
        boundArray.push(getCountryBounds(homeCode));
        boundArray.push(getCountryBounds(awayCode));
        combinedBound = combineBounds(boundArray);
        boxZoom(combinedBound, 20);

        homeFeature = countriesGroup.selectAll('path')
          .filter(function(d) {
            return d.properties.iso_a3 === homeCode;
          })
        ;
        awayFeature = countriesGroup.selectAll('path')
          .filter(function(d) {
            return d.properties.iso_a3 === awayCode;
          })
        ;
        homeArrow
          .attr("x2", getCountryCentroid(homeFeature.datum())[0])
          .attr("y2", getCountryCentroid(homeFeature.datum())[1])
        ;
        awayArrow
          .attr("x2", getCountryCentroid(awayFeature.datum())[0])
          .attr("y2", getCountryCentroid(awayFeature.datum())[1])
        ;
  }

      // display the passed game as a past game (i.e. change the colours to represent previous success)
      function displayPast(gameNo){
        gameID = "#game"+gameNo;
        pastHome = gamesData[gameNo-1][1];
        pastAway = gamesData[gameNo-1][3];
        homeIndex=findTeamIndex(pastHome);
        awayIndex=findTeamIndex(pastAway);
        // update country colours for each team
        if(teamsData[homeIndex][4]>0){
          countryFill(homeCode,pastChampionColour);
        }else{
          countryFill(homeCode,pastChallengerColour);
        }
        if(teamsData[awayIndex][4]>0){
          countryFill(awayCode,pastChampionColour);
        }else{
          countryFill(awayCode,pastChallengerColour);
        }
      }

      function goToFirst(){
        goToGame(1);
      }
      
      function goToLast(){
        goToGame(gamesData.length);
      }
      
      function goToGame(gameNo){
        stopVis();
        // reset score labels
        $(".scoreLabel").hide();
        // reset colour for progress buttons
        $(".progressButton").css('background-color', challengerColour);
        // reset colours for all countries
        countriesGroup.selectAll('path')
          .style('stroke', landColour)
          .style('stroke-width', 1)
        ;
        countriesGroup.selectAll('path')
          .style('fill', landColour)
        ;
        // reset stats for each team
        for(i=0;i<teamsData.length;i++){
          teamsData[i][1]=0;
          teamsData[i][3]=0;
          teamsData[i][4]=0;
        }
        // update game stats and colours for each country up to requested game
        champ=-1;
        for(i=0;i<gameNo;i++){
          newHome = gamesData[i][1];
          newAway = gamesData[i][3];
          newWinner = gamesData[i][0];
          homeIndex=findTeamIndex(newHome);
          awayIndex=findTeamIndex(newAway);
          winnerIndex=findTeamIndex(newWinner);
          homeCode = findTeamCode(newHome);
          awayCode = findTeamCode(newAway);
          winnerCode = findTeamCode(newWinner);
          // each team has played one more game
          teamsData[homeIndex][3]++;
          teamsData[awayIndex][3]++;
          // was it a "real" win?
//          scoreArray = gamesData[i][2].split("-");
//          if(scoreArray.length==2){
//            if(scoreArray[0].trim()!==scoreArray[1].trim()){
              // winning team has won one more game
              teamsData[winnerIndex][4]++;
//            }
//          }
          d3.select("#labelScore"+winnerCode).text(teamsData[winnerIndex][4]);
          $("#scoreLabel"+winnerCode).show();
          // if new champion that team has been champion one more
          if(winnerIndex!=champ){
            teamsData[winnerIndex][1]++;
            champ=winnerIndex;
          }
          // update country colours for each team
          if(teamsData[homeIndex][4]>0){
            countryFill(homeCode,pastChampionColour);
          }else{
            countryFill(homeCode,pastChallengerColour);
          }
          if(teamsData[awayIndex][4]>0){
            countryFill(awayCode,pastChampionColour);
          }else{
            countryFill(awayCode,pastChallengerColour);
          }
        }
        // set current game
        currentGame=gameNo;
        // display current game
        displayGame(gameNo);
      }

      function advanceGame(){
        // get current champ
        champ = gamesData[currentGame-1][0];
        champIndex = findTeamIndex(champ);
        // get old details
        oldHome = gamesData[currentGame-1][1];
        oldAway = gamesData[currentGame-1][3];
        oldWinner = gamesData[currentGame-1][0];
        oldHomeIndex=findTeamIndex(newHome);
        oldAwayIndex=findTeamIndex(newAway);
        oldWinnerIndex=findTeamIndex(newWinner);
        oldHomeCode = findTeamCode(newHome);
        oldAwayCode = findTeamCode(newAway);
        oldWinnerCode = findTeamCode(newWinner);

        // remove "challenger" colour from loser
        if(oldHomeCode!=oldWinnerCode){
          if(teamsData[oldHomeIndex][4]>0){
            countryFill(oldHomeCode,pastChampionColour);
          }else{
            countryFill(oldHomeCode,pastChallengerColour);
          }
        }
        if(oldAwayCode!=oldWinnerCode){
          if(teamsData[oldAwayIndex][4]>0){
            countryFill(oldAwayCode,pastChampionColour);
          }else{
            countryFill(oldAwayCode,pastChallengerColour);
          }
        }
        // increment game count
        currentGame++;
        // update team stats
        newHome = gamesData[currentGame-1][1];
        newAway = gamesData[currentGame-1][3];
        newWinner = gamesData[currentGame-1][0];
        homeIndex=findTeamIndex(newHome);
        awayIndex=findTeamIndex(newAway);
        winnerIndex=findTeamIndex(newWinner);
        homeCode = findTeamCode(newHome);
        awayCode = findTeamCode(newAway);
        winnerCode = findTeamCode(newWinner);
        // each team has played one more game
        teamsData[homeIndex][3]++;
        teamsData[awayIndex][3]++;
        // was it a "real" win?
//        scoreArray = gamesData[currentGame-1][2].split("-");
//        if(scoreArray.length==2){
//          if(scoreArray[0].trim()!==scoreArray[1].trim()){
            // winning team has won one more game
            teamsData[winnerIndex][4]++;
//          }
//        }
        // if new champion that team has been champion one more
        if(winnerIndex!=champIndex){
          teamsData[winnerIndex][1]++;
        }
        // display this game
        displayGame(currentGame);
        // stop if at last game
        if(currentGame>=gamesData.length){
          stopVis();
        }
      }
      

      function playVis(){
        if(!playing){
          $("#play").attr("src","images/icons/play-off.png");
          $("#pause").attr("src","images/icons/pause-on.png");
          if(frameGap<=minGap){
            $("#faster").attr("src","images/icons/forward-off.png");
          }else{
            $("#faster").attr("src","images/icons/forward-on.png");
          }
          if(frameGap>=maxGap){
            $("#slower").attr("src","images/icons/rewind-off.png");
          }else{
            $("#slower").attr("src","images/icons/rewind-on.png");
          }
          if(currentGame>=gamesData.length){
            goToFirst();
          }
          playing = true;
          runVis = setInterval(advanceGame, frameGap);
        }
      }

      function stopVis(){
        if(playing){
          $("#play").attr("src","images/icons/play-on.png");
          $("#pause").attr("src","images/icons/pause-off.png");
          $("#faster").attr("src","images/icons/forward-off.png");
          $("#slower").attr("src","images/icons/rewind-off.png");
          playing = false;
          clearInterval(runVis);
        }
      }

      function slower(){
        if(playing){
          stopVis();
          if(frameGap<maxGap)frameGap+=300;
          if(frameGap>=maxGap){
            $("#slower").attr("src","images/icons/rewind-off.png");
          }
          zoomDuration = frameGap/3;
          playVis();
        }
      }

      function faster(){
        if(playing){
          stopVis();
          if(frameGap>minGap)frameGap-=300;
          if(frameGap<=minGap){
            $("#faster").attr("src","images/icons/forward-off.png");
          }
          zoomDuration = frameGap/3;
          playVis();
        }
      }

      $(window).on('load', function() {
        $("#overlay").click(function (event){
          console.log(event.target);
          if($(event.target).is("#overlay")) {
            closeOverlay();
          }
        })
        progress = d3.select("#progressBar");
        for(i=1;i<=gamesData.length;i++){
          progress
            .append("div")
            .attr("class","progressButton")
            .attr("id","progButton"+(i))
            .attr('game-id',i)
            .style("width", ($(window).width()/gamesData.length) + "px")
            .style("background-color", challengerColour)
            .on('click', function(d,i) {
              goToGame(d3.select(this).attr("game-id"));
            })
            .on('mouseover', function(d,i) {
              moveProgressFlag(d3.select(this).attr("game-id"));
            })
            .on('mouseout', function(d,i) {
              moveProgressFlag();
            })
          ;
        }
      });

    </script>


  </body>
</html>